E/16/200
Lakmali B. L. S

_____________________________________________________________________________________________

1. There is no single “server” in a publish-subscribe system to store all tasks. Where are the tasks stored in the system?
 
 There isn't a server here to store the tasks as in client-server archiechture.
 Here, we are using peer to peer architechture. Every peer in the network keeps individual memory 
 keeping all the tasks individually. So, tasks are locally stored by each subscribed users. When
 the new task is added in the neywork, user can sync locally stored task with newest updates. 


2.Who should generate task IDs? How should they be generated, avoiding collisions?
  
  When new task is added, task ids are generated by each peer using universally unique id. 
  Algorithms use to generate uuid might be hashing algorithms or hierarchical structure.
  So, task id generation will do by user itself. Simply user can maintain local task id
  which is incremented whenever published a task.To avoid collisions we can use user's 
  subscription id (that is unique id gained when subscribing to the topic) and local task id
  to generate final unique task id. That will avoid collisions.
  

3. How can we represent the Task API ADD and DELETEoperations in a pub-sub system like MQTT? 

   We can include each operation in a topic or include the operations in the body.


   Under what assumptions is a LIST operation (not) required?

   Each peer in the network should maintain own task list. If one of them is
   not connected to network, others can update the task list. So, to obtain the updated 
   task list after re-connecting that peer, the List operation is required. So, if client 
   connections are breaking and if new clients are joining in the middle, we have to have
   LIST operation.
   
   
4. When implementing the Task API operations on MQTT, comment on if, and how you would use the
   following MQTT features.

    a. Quality of service (0, 1, 2).

        Use Qos leve 1
        Qos level 1 will be used for all operations (ADD, DELETE, LIST) , since it is easy to 
        implement and it is very reliable. When message is sent, it waits for acknowledgement.
        We use Qos 2 for only critical situations because, it uses 4-way handshake and it takes
        more time than other levels.So,for task api, Qos 1 is appropriate.

    b. Clean session flag on topic subscription.

	Use clean session flag - False
        We can set clean session flag as False when subscribing to a topic. So, in case client 
        client disconnect from the network, it will recognize him and subscription data will be
        stored in the broker and we don't need to subscribe again to the relevant topics. Otherwise,
        when connecting again to the broker it will recognize him as a new user. So we have to 
        subscribe all the topics again.

    c. Retained flag on message publication.

        Use retained flag - True
        When retained flag set in publication a topic, the broker will keep a copy of published
        message even after that is sent back to all subsscribed clients. If a new subscription 
        made to that topic retained message will be sent immadiately to that client. 
        By using this when publish  a topic most recent publication will be stored in the 
        broker and send when new client is connected. So new client can know last
        added task easily.

    

5. Two students are arguing about how to structure topics
    a. Student a suggests OPERATION/ID/STATE
    b. Student b suggests STATE/ID/OPERATION
   Either choose one of these proposals or suggest your own scheme stating your reasons.


   Both option a and option b can be used because of the wildcard facility of the mqtt.


6. Student c suggests including description in the topic as well. Argue for or against this 
   suggestion.
   
   It is not good to include description in the topic. The reason is topic is carried with every
   publish and subscribe packet. So, including description in topic will increase the topic size. 
   So, it is better to keep the topic as short otherwise it is waste of bandwidth. 
   
   Also, in mqtt protocol, max length is less than the max payload length. If the topic length
   is greater than it's max value, broker will ignore that. So we can avoid that by sending 
   the data on the payload.









